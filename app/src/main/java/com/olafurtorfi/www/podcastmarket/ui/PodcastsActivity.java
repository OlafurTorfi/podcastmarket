package com.olafurtorfi.www.podcastmarket.ui;

import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.support.v7.widget.RecyclerView;
import android.util.Log;

import com.olafurtorfi.www.podcastmarket.data.EpisodeContract;
import com.olafurtorfi.www.podcastmarket.data.PodcastContract;
import com.olafurtorfi.www.podcastmarket.sync.PodcastSyncUtil;

public class PodcastsActivity extends ListActivity implements
        LoaderManager.LoaderCallbacks<Cursor>,
        PodcastAdapter.PodcastAdapterOnClickHandler {

    /*
    * The columns of data that we are interested in displaying within our MainActivity's list of
    * podcast data.
    */
    public static final String[] MAIN_PODCAST_PROJECTION = {
            PodcastContract.PodcastEntry.COLUMN_ID,
            PodcastContract.PodcastEntry.COLUMN_TITLE,
            PodcastContract.PodcastEntry.COLUMN_AUTHOR,
            PodcastContract.PodcastEntry.COLUMN_DESCRIPTION,
    };

    /*
     * We store the indices of the values in the array of Strings above to more quickly be able to
     * access the data from our query. If the order of the Strings above changes, these indices
     * must be adjusted to match the order of the Strings.
     */
    public static final int INDEX_PODCAST_ID = 0;
    public static final int INDEX_PODCAST_TITLE = 1;
    public static final int INDEX_PODCAST_AUTHOR = 2;
    public static final int INDEX_PODCAST_DESCRIPTION = 3;




    /*
     * This ID will be used to identify the Loader responsible for loading our podcast podcast. In
     * some cases, one Activity can deal with many Loaders. However, in our case, there is only one.
     * We will still use this ID to initialize the loader and create the loader for best practice.
     * Please note that 44 was chosen arbitrarily. You can use whatever number you like, so long as
     * it is unique and consistent.
     */
    private static final int ID_PODCAST_LOADER = 44;

    private PodcastAdapter mPodcastAdapter;
//
//    private RecyclerView mRecyclerView;

    private int mPosition = android.support.v7.widget.RecyclerView.NO_POSITION;

//    private ProgressBar mLoadingIndicator;
    private String TAG = "Podcasts Activity";
    private Uri mUri;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mPodcastAdapter = new PodcastAdapter(this, this);

        /* Setting the adapter attaches it to the RecyclerView in our layout. */
        mRecyclerView.setAdapter(mPodcastAdapter);

//        mUri = getIntent().getData();
//        if (mUri == null) throw new NullPointerException("URI for PodcastActivity cannot be null");
        /*
         * Ensures a loader is initialized and active. If the loader doesn't already exist, one is
         * created and (if the activity/fragment is currently started) starts the loader. Otherwise
         * the last created loader is re-used.
         */
        getSupportLoaderManager().initLoader(ID_PODCAST_LOADER, null, this);

        PodcastSyncUtil.initialize(this);

    }
    @Override
    public Loader<Cursor> onCreateLoader(int loaderId, Bundle bundle) {

        Log.i("MainActivity", "creating loader, get cursor");
        switch (loaderId) {

            case ID_PODCAST_LOADER:
                /* URI for all rows of podcast data in our podcast table */
                Uri podcastQueryUri = PodcastContract.PodcastEntry.CONTENT_URI;
                /* Sort order: Ascending by date */
                String sortOrder = PodcastContract.PodcastEntry.COLUMN_TITLE + " ASC";

                return new CursorLoader(this,
                        podcastQueryUri,
                        MAIN_PODCAST_PROJECTION,
                        null,
                        null,
                        sortOrder);

            default:
                throw new RuntimeException("Loader Not Implemented: " + loaderId);
        }
    }

    /**
     * Called when a Loader has finished loading its data.
     *
     * NOTE: There is one small bug in this code. If no data is present in the cursor do to an
     * initial load being performed with no access to internet, the loading indicator will show
     * indefinitely, until data is present from the ContentProvider. This will be fixed in a
     * future version of the course.
     *
     * @param loader The Loader that has finished.
     * @param data   The data generated by the Loader.
     */
    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        Log.i("MainActivity", "log finished, cursor count: " + data.getCount());


        mPodcastAdapter.swapCursor(data);
        if (mPosition == RecyclerView.NO_POSITION) mPosition = 0;
        mRecyclerView.smoothScrollToPosition(mPosition);
        if (data.getCount() != 0) showDataView();
    }

    /**
     * Called when a previously created loader is being reset, and thus making its data unavailable.
     * The application should at this point remove any references it has to the Loader's data.
     *
     * @param loader The Loader that is being reset.
     */
    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        /*
         * Since this Loader's data is now invalid, we need to clear the Adapter that is
         * displaying the data.
         */
        mPodcastAdapter.swapCursor(null);
    }

    @Override
    public void onClick(String podcast) {
        Log.d("Main Activity", "On click.....");
        Intent episodeIntent = new Intent(PodcastsActivity.this, EpisodeActivity.class);
        Uri uriForPodcastClicked = EpisodeContract.EpisodeEntry.buildEpisodeUriWithPodcast(podcast);
        episodeIntent.setData(uriForPodcastClicked);
        Log.d("Main Activity", uriForPodcastClicked.toString());
        startActivity(episodeIntent);
    }
}
